.\" Automatically generated by Pod::Man 2.12 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title ".::src::libgbsed::libgbsed.c 3"
.TH .::src::libgbsed::libgbsed.c 3 "2007-07-16" "perl v5.9.5" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
libgbsed \- Search/Replace in binary files.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    #include <libgbsed.h>
\&
\&    // using file names.
\&    struct gbsed_arguments
\&    {
\&        char *search;
\&        char *replace;
\&        char *infilename;
\&        char *outfilename;
\&        int  minmatch;
\&        int  maxmatch;
\&    };
\&
\&    typedef struct gbsed_arguments GBSEDargs;
\&    
\&    int
\&    gbsed_binary_search_replace(struct gbsed_arguments *)
\&
\&    // using FILE*s 
\&    struct fgbsed_arguments
\&    {
\&        char *search;
\&        char *replace;
\&        FILE *infile;
\&        FILE *outfile;
\&        int   minmatch;
\&        int   maxmatch;
\&    };
\&    typedef struct fgbsed_arguments fGBSEDargs;
\&
\&    int
\&    gbsed_fbinary_search_replace(struct fgbsed_arguments *);
\&
\&    // Error handling
\&
\&    extern int
\&    gbsed_errno;
\&
\&    const char*
\&    gbsed_errtostr(int);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is <libgbsed>, a binary stream editor.
.PP
\&\f(CW\*(C`gbsed\*(C'\fR lets you search and replace binary data in binary files by using hex
values in text strings as search patterns. You can also use wildcard matches
with \f(CW\*(C`??\*(C'\fR, which will match any wide byte.
.PP
These are all valid search strings:
.PP
.Vb 3
\&    search = "0xffc300193ab2f63a";
\&    search = "0xff??00??3ab2f??a";
\&    search = "FF??00??3AB2F??A";
.Ve
.PP
while these are not:
.PP
.Vb 3
\&    search = "the quick brown fox"; // only hex, no text. you would have to
\&                                    // convert the text to hex first.
\&    search = "0xff?c33ab3?accc";    // no nybbles only wide bytes. (?? not ?).
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .Sh """gbsed_binary_search_replace(struct bsed_arguments *)"""
.el .Sh "\f(CWgbsed_binary_search_replace(struct bsed_arguments *)\fP"
.IX Subsection "gbsed_binary_search_replace(struct bsed_arguments *)"
\fI\s-1ARGUMENTS\s0\fR
.IX Subsection "ARGUMENTS"
.PP
\&\f(CW\*(C`gbsed_binary_search_replace\*(C'\fR uses a struct for it's arguments.
The members of the argument struct is as follows:
.ie n .IP """unsigned char *searchin""" 4
.el .IP "\f(CWunsigned char *searchin\fR" 4
.IX Item "unsigned char *searchin"
What to search for. This must be a string with hex values or the wildcard
character sequence \f(CW\*(C`??\*(C'\fR, which will match any byte. The string
can start with \f(CW\*(C`0x\*(C'\fR, but this is optional.
.ie n .IP """unsigned char *replacein""" 4
.el .IP "\f(CWunsigned char *replacein\fR" 4
.IX Item "unsigned char *replacein"
What to replace with. Must also be a string with hex values,
but no wildcards allowed. It must also be of the same length
as the search string (This is by intention, as binary data is always
in structured form. If you add extra information to a binary executable
it will be rendered useless as address offsets will be shifted and
relocation tables and internal address references will point to the
wrong place).
.ie n .IP """unsigned char *ifilenm""" 4
.el .IP "\f(CWunsigned char *ifilenm\fR" 4
.IX Item "unsigned char *ifilenm"
The file name of the file to search in.
.ie n .IP """unsigned char *ofilenm""" 4
.el .IP "\f(CWunsigned char *ofilenm\fR" 4
.IX Item "unsigned char *ofilenm"
The file name to save the modified binary as.
.ie n .IP """int minmatch""" 4
.el .IP "\f(CWint minmatch\fR" 4
.IX Item "int minmatch"
Need at least \f(CW\*(C`minmatch\*(C'\fR matches before any work.
.ie n .IP """int maxmatch""" 4
.el .IP "\f(CWint maxmatch\fR" 4
.IX Item "int maxmatch"
Stop after \f(CW\*(C`maxmatch\*(C'\fR matches. A value of \f(CW\*(C`\-1\*(C'\fR means no limit.
.PP
\fI\s-1EXAMPLE\s0 \s-1USAGE\s0\fR
.IX Subsection "EXAMPLE USAGE"
.PP
.Vb 3
\&    #include <stdlib.h>
\&    #include <stdio.h>
\&    #include <libgbsed.h>
\&    
\&    extern int gbsed_errno;
\&
\&    int main(int argc, char **argv) {
\&
\&        int         gbsed_ret;
\&        int         sysret;
\&        const char *errmessage;
\&        GBSEDargs   *bargs;
\&
\&        sysret  = EXIT_SUCCESS;
\&        bargs   = (GBSEDargs *)malloc(sizeof(GBSEDargs));
\&        if (bargs == NULL) {
\&            fprintf(stderr, "Out of memory!\en");
\&            exit(1);
\&        }
\&
\&        bargs\->search      = "0xff";
\&        bargs\->replace     = "0x00";
\&        bargs\->infilename  = "/bin/ls";
\&        bargs\->outfilename = "bsed.out";
\&        bargs\->minmatch    =  1;                        // atleast one match.
\&        bargs\->maxmatch    = GBSED_MAXMATCH_NO_LIMIT;   // no limit.
\&
\&        if (argc > 1)
\&            bargs\->infilename  = argv[1];
\&
\&        gbsed_ret = gbsed_binary_search_replace(bargs);
\&
\&        switch (gbsed_ret) {
\&            
\&            case GBSED_ERROR:
\&                errmessage = gbsed_errtostr(gbsed_errno);
\&                fprintf(stderr, "ERROR: %s\en", errmessage);
\&                sysret = EXIT_FAILURE;
\&                break;
\&            case GBSED_NO_MATCH:
\&                fprintf(stderr, "No match for %s found in %s\en",
\&                    bargs\->search, bargs\->infilename
\&                );
\&                sysret = EXIT_FAILURE;
\&                break;
\&            
\&            default:
\&                printf("Search for '%s' in '%s' matched %d times.\en",
\&                    bargs\->search, bargs\->infilename, gbsed_ret
\&                );
\&                break;
\&        }
\&        
\&        free(bargs);
\&        return sysret;
\&    }
.Ve
.ie n .Sh """const char * gbsed_errtostr(int)"""
.el .Sh "\f(CWconst char * gbsed_errtostr(int)\fP"
.IX Subsection "const char * gbsed_errtostr(int)"
This function returns a string describing what happened.
if an error has occurred with either \f(CW\*(C`gbsed_binary_search_replace\*(C'\fR or
\&\f(CW\*(C`binary_file_matches\*(C'\fR.
.PP
Example:
.PP
.Vb 1
\&    extern int gbsed_errno;
\&
\&    const char *errmessage;
\&    errmessage = gbsed_errtostr(gbsed_errno);
\&    fprintf(stderr, "ERROR: %s\en", errmessage);
.Ve
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\f(CW\*(C`gbsed_binary_search_replace\*(C'\fR returns \f(CW\*(C`GBSED_ERROR\*(C'\fR on failure.
The error code can then be found in \f(CW\*(C`gbsed_errno\*(C'\fR, error codes are defined in \fIlibgbsed.h\fR.
and they all start with \f(CW\*(C`GBSED_\*(C'\fR and is \f(CW\*(C`int\*(C'\fR. To get a string containing the
error message you have to call \f(CW\*(C`bsed_errtomsg\*(C'\fR with \f(CW\*(C`bsed_errno\*(C'\fR as argument.
.ie n .Sh "Error codes returned by ""gbsed_binary_search_replace()"""
.el .Sh "Error codes returned by \f(CWgbsed_binary_search_replace()\fP"
.IX Subsection "Error codes returned by gbsed_binary_search_replace()"
\fI\f(CI\*(C`GBSED_NO_MATCH\*(C'\fI\fR
.IX Subsection "GBSED_NO_MATCH"
.PP
No matches found.
.PP
\fI\f(CI\*(C`GBSED_ERROR\*(C'\fI\fR
.IX Subsection "GBSED_ERROR"
.PP
An error has occurred and a error code has been left in \f(CW\*(C`gbsed_errno\*(C'\fR.
.ie n .Sh "Error codes found in ""gbsed_errno"""
.el .Sh "Error codes found in \f(CWgbsed_errno\fP"
.IX Subsection "Error codes found in gbsed_errno"
\fI\f(CI\*(C`GBSED_ESEARCH_TOO_LONG\*(C'\fI\fR
.IX Subsection "GBSED_ESEARCH_TOO_LONG"
.PP
Search string was longer than the limit.
.PP
\fI\f(CI\*(C`GBSED_EREPLACE_TOO_LONG\*(C'\fI\fR
.IX Subsection "GBSED_EREPLACE_TOO_LONG"
.PP
Replace string was longer than the limit.
.PP
\fI\f(CI\*(C`GBSED_ENULL_SEARCH\*(C'\fI\fR
.IX Subsection "GBSED_ENULL_SEARCH"
.PP
Missing search string.
.PP
\fI\f(CI\*(C`GBSED_ENULL_REPLACE\*(C'\fI\fR
.IX Subsection "GBSED_ENULL_REPLACE"
.PP
Missing replace string.
.PP
\fI\f(CI\*(C`GBSED_EMISSING_INPUT\*(C'\fI\fR
.IX Subsection "GBSED_EMISSING_INPUT"
.PP
Missing input filename.
.PP
\fI\f(CI\*(C`GBSED_EMISSING_OUTPUT\*(C'\fI\fR
.IX Subsection "GBSED_EMISSING_OUTPUT"
.PP
Missing output filename.
.PP
\fI\f(CI\*(C`GBSED_EINVALID_CHAR\*(C'\fI\fR
.IX Subsection "GBSED_EINVALID_CHAR"
.PP
Invalid characters in search string. Only hex values and wildcards
are allowed.
.PP
\fI\f(CI\*(C`GBSED_ENIBBLE_NOT_BYTE\*(C'\fI\fR
.IX Subsection "GBSED_ENIBBLE_NOT_BYTE"
.PP
Wildcard must be wild byte, not nibble.  (\f(CW\*(C`??\*(C'\fR not \f(CW\*(C`?\*(C'\fR).
.SH "CONFIGURATION AND ENVIRONMENT"
.IX Header "CONFIGURATION AND ENVIRONMENT"
\&\f(CW\*(C`libgbsed\*(C'\fR requires no configuration file or environment variables.
.SH "INCOMPATIBILITIES"
.IX Header "INCOMPATIBILITIES"
None known.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
No bugs have been reported.
.PP
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-file\-bsed@rt.cpan.org\*(C'\fR, or through the web interface at
<http://rt.cpan.org>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
gbsed
.SH "AUTHOR"
.IX Header "AUTHOR"
Ask Solem,   \f(CW\*(C`ask@0x61736b.net\*(C'\fR.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Dave Dykstra \f(CW\*(C`dwdbsed@drdykstra.us\*(C'\fR.
for \f(CW\*(C`bsed\*(C'\fR the original program,
.PP
\&\fI0xfeedface\fR
for the wildcards patch.
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright (C) 2007 Ask Solem <ask@0x61736b.net>
.PP
gbsed is free software; you can redistribute it and/or modify
it under the terms of the \s-1GNU\s0 General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.
.PP
gbsed is distributed in the hope that it will be useful,
but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.  See the
\&\s-1GNU\s0 General Public License for more details.
.PP
You should have received a copy of the \s-1GNU\s0 General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
.SH "DISCLAIMER OF WARRANTY"
.IX Header "DISCLAIMER OF WARRANTY"
\&\s-1BECAUSE\s0 \s-1THIS\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1LICENSED\s0 \s-1FREE\s0 \s-1OF\s0 \s-1CHARGE\s0, \s-1THERE\s0 \s-1IS\s0 \s-1NO\s0 \s-1WARRANTY\s0 \s-1FOR\s0 \s-1THE\s0
\&\s-1SOFTWARE\s0, \s-1TO\s0 \s-1THE\s0 \s-1EXTENT\s0 \s-1PERMITTED\s0 \s-1BY\s0 \s-1APPLICABLE\s0 \s-1LAW\s0. \s-1EXCEPT\s0 \s-1WHEN\s0 \s-1OTHERWISE\s0
\&\s-1STATED\s0 \s-1IN\s0 \s-1WRITING\s0 \s-1THE\s0 \s-1COPYRIGHT\s0 \s-1HOLDERS\s0 \s-1AND/OR\s0 \s-1OTHER\s0 \s-1PARTIES\s0 \s-1PROVIDE\s0 \s-1THE\s0
\&\s-1SOFTWARE\s0 \*(L"\s-1AS\s0 \s-1IS\s0\*(R" \s-1WITHOUT\s0 \s-1WARRANTY\s0 \s-1OF\s0 \s-1ANY\s0 \s-1KIND\s0, \s-1EITHER\s0 \s-1EXPRESSED\s0 \s-1OR\s0 \s-1IMPLIED\s0,
\&\s-1INCLUDING\s0, \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0, \s-1THE\s0 \s-1IMPLIED\s0 \s-1WARRANTIES\s0 \s-1OF\s0 \s-1MERCHANTABILITY\s0 \s-1AND\s0
\&\s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0. \s-1THE\s0 \s-1ENTIRE\s0 \s-1RISK\s0 \s-1AS\s0 \s-1TO\s0 \s-1THE\s0 \s-1QUALITY\s0 \s-1AND\s0
\&\s-1PERFORMANCE\s0 \s-1OF\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1WITH\s0 \s-1YOU\s0. \s-1SHOULD\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1PROVE\s0 \s-1DEFECTIVE\s0,
\&\s-1YOU\s0 \s-1ASSUME\s0 \s-1THE\s0 \s-1COST\s0 \s-1OF\s0 \s-1ALL\s0 \s-1NECESSARY\s0 \s-1SERVICING\s0, \s-1REPAIR\s0, \s-1OR\s0 \s-1CORRECTION\s0.
.PP
\&\s-1IN\s0 \s-1NO\s0 \s-1EVENT\s0 \s-1UNLESS\s0 \s-1REQUIRED\s0 \s-1BY\s0 \s-1APPLICABLE\s0 \s-1LAW\s0 \s-1OR\s0 \s-1AGREED\s0 \s-1TO\s0 \s-1IN\s0 \s-1WRITING\s0 \s-1WILL\s0 \s-1ANY\s0
\&\s-1COPYRIGHT\s0 \s-1HOLDER\s0, \s-1OR\s0 \s-1ANY\s0 \s-1OTHER\s0 \s-1PARTY\s0 \s-1WHO\s0 \s-1MAY\s0 \s-1MODIFY\s0 \s-1AND/OR\s0 \s-1REDISTRIBUTE\s0 \s-1THE\s0
\&\s-1SOFTWARE\s0 \s-1AS\s0 \s-1PERMITTED\s0 \s-1BY\s0 \s-1THE\s0 \s-1ABOVE\s0 \s-1LICENCE\s0, \s-1BE\s0 \s-1LIABLE\s0 \s-1TO\s0 \s-1YOU\s0 \s-1FOR\s0 \s-1DAMAGES\s0,
\&\s-1INCLUDING\s0 \s-1ANY\s0 \s-1GENERAL\s0, \s-1SPECIAL\s0, \s-1INCIDENTAL\s0, \s-1OR\s0 \s-1CONSEQUENTIAL\s0 \s-1DAMAGES\s0 \s-1ARISING\s0
\&\s-1OUT\s0 \s-1OF\s0 \s-1THE\s0 \s-1USE\s0 \s-1OR\s0 \s-1INABILITY\s0 \s-1TO\s0 \s-1USE\s0 \s-1THE\s0 \s-1SOFTWARE\s0 (\s-1INCLUDING\s0 \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0
\&\s-1LOSS\s0 \s-1OF\s0 \s-1DATA\s0 \s-1OR\s0 \s-1DATA\s0 \s-1BEING\s0 \s-1RENDERED\s0 \s-1INACCURATE\s0 \s-1OR\s0 \s-1LOSSES\s0 \s-1SUSTAINED\s0 \s-1BY\s0 \s-1YOU\s0 \s-1OR\s0
\&\s-1THIRD\s0 \s-1PARTIES\s0 \s-1OR\s0 A \s-1FAILURE\s0 \s-1OF\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1TO\s0 \s-1OPERATE\s0 \s-1WITH\s0 \s-1ANY\s0 \s-1OTHER\s0
\&\s-1SOFTWARE\s0), \s-1EVEN\s0 \s-1IF\s0 \s-1SUCH\s0 \s-1HOLDER\s0 \s-1OR\s0 \s-1OTHER\s0 \s-1PARTY\s0 \s-1HAS\s0 \s-1BEEN\s0 \s-1ADVISED\s0 \s-1OF\s0 \s-1THE\s0
\&\s-1POSSIBILITY\s0 \s-1OF\s0 \s-1SUCH\s0 \s-1DAMAGES\s0.
